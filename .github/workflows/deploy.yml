name: Deploy to GKE

on:
  push:
    branches: [main]

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GKE_CLUSTER: medisupply-cluster
  GKE_REGION: us-central1
  REGISTRY: us-central1-docker.pkg.dev

jobs:
  deploy:
    name: Deploy to GKE
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
        project_id: ${{ secrets.GCP_PROJECT_ID }}

    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2

    - name: Install GKE Auth Plugin
      run: |
        gcloud components install gke-gcloud-auth-plugin
        echo "USE_GKE_GCLOUD_AUTH_PLUGIN=True" >> $GITHUB_ENV

    - name: Configure Docker for Artifact Registry
      run: gcloud --quiet auth configure-docker us-central1-docker.pkg.dev

    - name: Get GKE credentials
      run: |
        export USE_GKE_GCLOUD_AUTH_PLUGIN=True
        gcloud container clusters get-credentials $GKE_CLUSTER --region $GKE_REGION

    - name: Build and push user-service image
      run: |
        docker build -t $REGISTRY/$PROJECT_ID/medisupply/user-service:$GITHUB_SHA ./user-service
        docker tag $REGISTRY/$PROJECT_ID/medisupply/user-service:$GITHUB_SHA $REGISTRY/$PROJECT_ID/medisupply/user-service:latest
        docker push $REGISTRY/$PROJECT_ID/medisupply/user-service:$GITHUB_SHA
        docker push $REGISTRY/$PROJECT_ID/medisupply/user-service:latest

    - name: Build and push supplier-service image
      run: |
        docker build -t $REGISTRY/$PROJECT_ID/medisupply/supplier-service:$GITHUB_SHA ./medisupply-supplier-service
        docker tag $REGISTRY/$PROJECT_ID/medisupply/supplier-service:$GITHUB_SHA $REGISTRY/$PROJECT_ID/medisupply/supplier-service:latest
        docker push $REGISTRY/$PROJECT_ID/medisupply/supplier-service:$GITHUB_SHA
        docker push $REGISTRY/$PROJECT_ID/medisupply/supplier-service:latest

    - name: Build and push client-service image
      run: |
        docker build -t $REGISTRY/$PROJECT_ID/medisupply/client-service:$GITHUB_SHA ./medisupply-client-service
        docker tag $REGISTRY/$PROJECT_ID/medisupply/client-service:$GITHUB_SHA $REGISTRY/$PROJECT_ID/medisupply/client-service:latest
        docker push $REGISTRY/$PROJECT_ID/medisupply/client-service:$GITHUB_SHA
        docker push $REGISTRY/$PROJECT_ID/medisupply/client-service:latest

    - name: Update Kubernetes manifests
      run: |
        # Replace PROJECT_ID and image tags in manifests
        find k8s -name "*-deployment.yaml" -exec sed -i "s/PROJECT_ID/$PROJECT_ID/g" {} \;
        find k8s -name "*-deployment.yaml" -exec sed -i "s/:latest/:$GITHUB_SHA/g" {} \;

    - name: Clean up before deploy
      env:
        USE_GKE_GCLOUD_AUTH_PLUGIN: True
      run: |
        echo "ğŸ§¹ Ejecutando limpieza pre-deploy..."
        ./scripts/cleanup-k8s.sh

    - name: Deploy to GKE
      env:
        USE_GKE_GCLOUD_AUTH_PLUGIN: True
      run: |
        # Aplicar namespace
        kubectl apply -f k8s/namespace.yaml
        
        # Verificar PVC y solo aplicar si no existe o no estÃ¡ Bound
        echo "ğŸ” Verificando PVC de PostgreSQL..."
        PVC_STATUS=$(kubectl get pvc postgres-pvc -n medisupply -o jsonpath='{.status.phase}' 2>/dev/null || echo "")
        PVC_STORAGE_CLASS=$(kubectl get pvc postgres-pvc -n medisupply -o jsonpath='{.spec.storageClassName}' 2>/dev/null || echo "")
        
        # Desplegar recursos de base de datos (usando emptyDir, sin PVC)
        echo "ğŸ“¦ Desplegando recursos de base de datos..."
        echo "â„¹ï¸  PostgreSQL usa emptyDir (sin persistencia) para evitar problemas con PVC en GKE Autopilot"
        echo "âš ï¸  ADVERTENCIA: Los datos se perderÃ¡n al reiniciar el pod de PostgreSQL"
        kubectl apply -f k8s/database/postgres-secret.yaml
        kubectl apply -f k8s/database/postgres-init-configmap.yaml
        kubectl apply -f k8s/database/postgres-service.yaml
        
        # Desplegar deployment de PostgreSQL
        echo "ğŸ“¦ Desplegando PostgreSQL deployment..."
        kubectl apply -f k8s/database/postgres-deployment.yaml
        
        # Desplegar servicios
        echo "ğŸ“¦ Desplegando servicios..."
        kubectl apply -f k8s/services/user-service/
        kubectl apply -f k8s/services/supplier-service/
        kubectl apply -f k8s/services/client-service/
        kubectl apply -f k8s/gateway/
        
        # Aplicar HPA para optimizaciÃ³n de costos
        echo "ğŸš€ Aplicando Horizontal Pod Autoscalers..."
        kubectl apply -f k8s/services/user-service/hpa-user-service.yaml || echo "HPA no encontrado, omitiendo..."
        kubectl apply -f k8s/services/supplier-service/hpa-supplier-service.yaml || echo "HPA no encontrado, omitiendo..."
        kubectl apply -f k8s/services/client-service/hpa-client-service.yaml || echo "HPA no encontrado, omitiendo..."
        
        # Esperar a que los deployments estÃ©n listos (sin bloqueos largos)
        echo "â³ Esperando deployments..."
        
        # User Service
        kubectl rollout status deployment/user-service-deployment -n medisupply --timeout=300s || {
          echo "âš ï¸  User-service rollout timeout"
          echo "ğŸ“‹ Estado del deployment:"
          kubectl describe deployment user-service-deployment -n medisupply | head -50
          echo "ğŸ“‹ Pods:"
          kubectl get pods -l app=user-service -n medisupply
          echo "ğŸ“‹ Logs (Ãºltimas 20 lÃ­neas):"
          kubectl logs -l app=user-service -n medisupply --tail=20 2>/dev/null || echo "No logs disponibles"
          
          # Si hay pods en Pending, intentar eliminarlos mÃºltiples veces hasta que se programe en otro nodo
          echo "ğŸ” Verificando pods en Pending de user-service..."
          MAX_ATTEMPTS=5
          ATTEMPT=0
          SUCCESS=false
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ] && [ "$SUCCESS" = "false" ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "ğŸ”„ Intento $ATTEMPT/$MAX_ATTEMPTS..."
            
            PENDING_USER_PODS=$(kubectl get pods -n medisupply -l app=user-service -o jsonpath='{range .items[?(@.status.phase=="Pending")]}{.metadata.name}{"\n"}{end}' 2>/dev/null || echo "")
            if [ -z "$PENDING_USER_PODS" ]; then
              echo "âœ… No hay pods en Pending, verificando si hay pods Running..."
              RUNNING_PODS=$(kubectl get pods -n medisupply -l app=user-service -o jsonpath='{range .items[?(@.status.phase=="Running")]}{.metadata.name}{"\n"}{end}' 2>/dev/null || echo "")
              if [ ! -z "$RUNNING_PODS" ]; then
                echo "âœ… Pod estÃ¡ Running!"
                SUCCESS=true
                break
              fi
            fi
            
            for POD in $PENDING_USER_PODS; do
              NODE=$(kubectl get pod $POD -n medisupply -o jsonpath='{.spec.nodeName}' 2>/dev/null || echo "")
              if [ -z "$NODE" ]; then
                # Buscar en eventos
                NODE=$(kubectl get events -n medisupply --field-selector involvedObject.name=$POD --sort-by='.lastTimestamp' -o jsonpath='{range .items[?(@.reason=="Scheduled")]}{.message}{end}' 2>/dev/null | grep -o 'to [^ ]*' | cut -d' ' -f2 || echo "")
              fi
              
              echo "Pod $POD en nodo: ${NODE:-desconocido}"
              
              # Si estÃ¡ en el nodo NAP problemÃ¡tico, eliminarlo
              if [ ! -z "$NODE" ] && echo "$NODE" | grep -q "nap-2dq838tl"; then
                echo "âš ï¸  Pod en nodo NAP problemÃ¡tico, eliminando..."
                kubectl delete pod $POD -n medisupply --grace-period=0 --force --timeout=10s 2>/dev/null || echo "âš ï¸  No se pudo eliminar pod $POD"
                echo "â³ Esperando 20s para que se recree..."
                sleep 20
                
                # Verificar si el nuevo pod estÃ¡ en un nodo diferente
                NEW_POD=$(kubectl get pod -n medisupply -l app=user-service -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
                if [ ! -z "$NEW_POD" ]; then
                  NEW_NODE=$(kubectl get pod $NEW_POD -n medisupply -o jsonpath='{.spec.nodeName}' 2>/dev/null || echo "")
                  if [ ! -z "$NEW_NODE" ] && ! echo "$NEW_NODE" | grep -q "nap-2dq838tl"; then
                    echo "âœ… Â¡Ã‰xito! Pod se programÃ³ en nodo diferente: $NEW_NODE"
                    SUCCESS=true
                    break
                  fi
                fi
              else
                echo "â„¹ï¸  Pod no estÃ¡ en nodo NAP problemÃ¡tico"
                SUCCESS=true
                break
              fi
            done
          done
          
          if [ "$SUCCESS" = "false" ]; then
            echo "âš ï¸  DespuÃ©s de $MAX_ATTEMPTS intentos, el pod sigue programÃ¡ndose en el nodo NAP"
            echo "ğŸ“‹ Estado final:"
            kubectl get pods -l app=user-service -n medisupply -o wide
            echo ""
            echo "ğŸ’¡ RecomendaciÃ³n: Contactar a Google Cloud Support sobre el nodo NAP inestable"
            echo "   Nodo problemÃ¡tico: gk3-medisupply-cluster-nap-2dq838tl-ae2fe6e2-zn8c"
          else
            echo "ğŸ“Š Estado final exitoso:"
            kubectl get pods -l app=user-service -n medisupply -o wide
          fi
        }
        
        # Supplier Service
        kubectl rollout status deployment/supplier-service-deployment -n medisupply --timeout=300s || {
          echo "âš ï¸  Supplier-service rollout timeout"
          echo "ğŸ“‹ Estado del deployment:"
          kubectl describe deployment supplier-service-deployment -n medisupply | head -50
          echo "ğŸ“‹ Pods:"
          kubectl get pods -l app=supplier-service -n medisupply
          echo "ğŸ“‹ Logs (Ãºltimas 20 lÃ­neas):"
          kubectl logs -l app=supplier-service -n medisupply --tail=20 2>/dev/null || echo "No logs disponibles"
        }
        
        # Client Service
        kubectl rollout status deployment/client-service-deployment -n medisupply --timeout=300s || {
          echo "âš ï¸  Client-service rollout timeout"
          echo "ğŸ“‹ Estado del deployment:"
          kubectl describe deployment client-service-deployment -n medisupply | head -50
          echo "ğŸ“‹ Pods:"
          kubectl get pods -l app=client-service -n medisupply
          echo "ğŸ“‹ Logs (Ãºltimas 20 lÃ­neas):"
          kubectl logs -l app=client-service -n medisupply --tail=20 2>/dev/null || echo "No logs disponibles"
        }
        
        # PostgreSQL (opcional, no bloquea)
        echo "â³ Verificando PostgreSQL..."
        kubectl rollout status deployment/postgres-deployment -n medisupply --timeout=180s || echo "âš ï¸  PostgreSQL rollout timeout, continuando..."
        
        # Limpiar pods en Pending en nodo NAP problemÃ¡tico (workaround para GKE Autopilot)
        echo "ğŸ” Verificando pods en nodo NAP problemÃ¡tico..."
        PENDING_PODS=$(kubectl get pods -n medisupply -o jsonpath='{range .items[?(@.status.phase=="Pending")]}{.metadata.name}{"\n"}{end}' 2>/dev/null || echo "")
        if [ ! -z "$PENDING_PODS" ]; then
          for POD in $PENDING_PODS; do
            # Verificar el nodo asignado usando spec.nodeName o buscar en eventos
            NODE=$(kubectl get pod $POD -n medisupply -o jsonpath='{.spec.nodeName}{.status.nominatedNodeName}' 2>/dev/null || echo "")
            # Si no tiene nodo asignado aÃºn, verificar eventos de scheduling
            if [ -z "$NODE" ]; then
              SCHEDULED_NODE=$(kubectl get events -n medisupply --field-selector involvedObject.name=$POD --sort-by='.lastTimestamp' -o jsonpath='{range .items[?(@.reason=="Scheduled")]}{.message}{end}' 2>/dev/null | grep -oP 'to \K[^\s]+' || echo "")
              NODE="$SCHEDULED_NODE"
            fi
            # Si el pod estÃ¡ en el nodo NAP problemÃ¡tico, eliminarlo
            if [ ! -z "$NODE" ] && echo "$NODE" | grep -q "nap-2dq838tl"; then
              echo "âš ï¸  Pod $POD estÃ¡ en Pending en nodo NAP problemÃ¡tico ($NODE)"
              echo "ğŸ—‘ï¸  Eliminando pod para forzar recreaciÃ³n en nodo estable..."
              kubectl delete pod $POD -n medisupply --grace-period=0 --force --timeout=10s 2>/dev/null || echo "âš ï¸  No se pudo eliminar pod $POD"
            elif [ ! -z "$POD" ]; then
              echo "â„¹ï¸  Pod $POD estÃ¡ en Pending en nodo: ${NODE:-no asignado aÃºn}"
            fi
          done
          if echo "$PENDING_PODS" | grep -q "."; then
            echo "â³ Esperando 30s para que los pods se recreen..."
            sleep 30
          fi
        fi

    - name: Verify deployment
      env:
        USE_GKE_GCLOUD_AUTH_PLUGIN: True
      run: |
        echo "ğŸ“Š Estado de pods:"
        kubectl get pods -n medisupply
        echo ""
        echo "ğŸ“Š Servicios:"
        kubectl get services -n medisupply
        echo ""
        echo "ğŸ“Š Gateway:"
        kubectl get gateway -n medisupply || echo "Gateway no disponible aÃºn"
        echo ""
        echo "ğŸ“Š HPA Status:"
        kubectl get hpa -n medisupply || echo "HPA no configurado"

    - name: Get Gateway IP
      id: get-ip
      env:
        USE_GKE_GCLOUD_AUTH_PLUGIN: True
      run: |
        echo "ğŸ” Esperando IP externa del Gateway..."
        for i in {1..30}; do
          IP=$(kubectl get gateway medisupply-gateway -n medisupply -o jsonpath='{.status.addresses[0].value}' 2>/dev/null || echo "")
          if [ ! -z "$IP" ]; then
            echo "ip=$IP" >> $GITHUB_OUTPUT
            echo "ğŸ‰ Â¡IP externa obtenida: $IP!"
            break
          fi
          echo "Esperando IP externa... (intento $i/30)"
          sleep 10
        done

    - name: Update deployment status
      if: steps.get-ip.outputs.ip != ''
      run: |
        echo "ğŸš€ Â¡Deploy exitoso!"
        echo "ğŸŒ URL de la aplicaciÃ³n: http://${{ steps.get-ip.outputs.ip }}"
        echo ""
        echo "â¤ï¸ HEALTH CHECKS:"
        echo "   User Service: http://${{ steps.get-ip.outputs.ip }}/health"
        echo "   Supplier Service: http://${{ steps.get-ip.outputs.ip }}/healthz"
        echo "   Client Service: http://${{ steps.get-ip.outputs.ip }}/client-health"
        echo ""
        echo "ğŸ”Œ APIS DISPONIBLES:"
        echo "   ğŸ‘¥ Usuarios: http://${{ steps.get-ip.outputs.ip }}/api/v1/users"
        echo "   ğŸ‘¥ Providers: http://${{ steps.get-ip.outputs.ip }}/api/v1/providers"
        echo "   ğŸ¥ Proveedores: http://${{ steps.get-ip.outputs.ip }}/api/v1/proveedores"
        echo "   ğŸ¥ Productos: http://${{ steps.get-ip.outputs.ip }}/api/v1/productos"
        echo "   ğŸ¥ Planes de venta: http://${{ steps.get-ip.outputs.ip }}/api/v1/planes-venta"
        echo "   ğŸ¥ Vendedores: http://${{ steps.get-ip.outputs.ip }}/api/v1/vendedores"
        echo "   ğŸ¥ PaÃ­ses: http://${{ steps.get-ip.outputs.ip }}/api/v1/paises"
        echo "   ğŸ¥ Certificaciones: http://${{ steps.get-ip.outputs.ip }}/api/v1/certificaciones"
        echo "   ğŸ¥ CategorÃ­as: http://${{ steps.get-ip.outputs.ip }}/api/v1/categorias-suministros"
        echo "   ğŸ¢ Clientes: http://${{ steps.get-ip.outputs.ip }}/api/v1/clientes"
