name: Deploy to GKE

on:
  push:
    branches: [main]

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GKE_CLUSTER: medisupply-cluster
  GKE_REGION: us-central1
  REGISTRY: us-central1-docker.pkg.dev

jobs:
  deploy:
    name: Deploy to GKE
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
        project_id: ${{ secrets.GCP_PROJECT_ID }}

    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2

    - name: Install GKE Auth Plugin
      run: |
        gcloud components install gke-gcloud-auth-plugin
        echo "USE_GKE_GCLOUD_AUTH_PLUGIN=True" >> $GITHUB_ENV

    - name: Configure Docker for Artifact Registry
      run: gcloud --quiet auth configure-docker us-central1-docker.pkg.dev

    - name: Get GKE credentials
      run: |
        export USE_GKE_GCLOUD_AUTH_PLUGIN=True
        gcloud container clusters get-credentials $GKE_CLUSTER --region $GKE_REGION

    - name: Build and push user-service image
      run: |
        docker build -t $REGISTRY/$PROJECT_ID/medisupply/user-service:$GITHUB_SHA ./user-service
        docker tag $REGISTRY/$PROJECT_ID/medisupply/user-service:$GITHUB_SHA $REGISTRY/$PROJECT_ID/medisupply/user-service:latest
        docker push $REGISTRY/$PROJECT_ID/medisupply/user-service:$GITHUB_SHA
        docker push $REGISTRY/$PROJECT_ID/medisupply/user-service:latest

    - name: Build and push supplier-service image
      run: |
        docker build -t $REGISTRY/$PROJECT_ID/medisupply/supplier-service:$GITHUB_SHA ./medisupply-supplier-service
        docker tag $REGISTRY/$PROJECT_ID/medisupply/supplier-service:$GITHUB_SHA $REGISTRY/$PROJECT_ID/medisupply/supplier-service:latest
        docker push $REGISTRY/$PROJECT_ID/medisupply/supplier-service:$GITHUB_SHA
        docker push $REGISTRY/$PROJECT_ID/medisupply/supplier-service:latest

    - name: Build and push client-service image
      run: |
        docker build -t $REGISTRY/$PROJECT_ID/medisupply/client-service:$GITHUB_SHA ./medisupply-client-service
        docker tag $REGISTRY/$PROJECT_ID/medisupply/client-service:$GITHUB_SHA $REGISTRY/$PROJECT_ID/medisupply/client-service:latest
        docker push $REGISTRY/$PROJECT_ID/medisupply/client-service:$GITHUB_SHA
        docker push $REGISTRY/$PROJECT_ID/medisupply/client-service:latest

    - name: Build and push edge-proxy image
      run: |
        docker build -t $REGISTRY/$PROJECT_ID/medisupply/edge-proxy:$GITHUB_SHA ./edge-proxy
        docker tag $REGISTRY/$PROJECT_ID/medisupply/edge-proxy:$GITHUB_SHA $REGISTRY/$PROJECT_ID/medisupply/edge-proxy:latest
        docker push $REGISTRY/$PROJECT_ID/medisupply/edge-proxy:$GITHUB_SHA
        docker push $REGISTRY/$PROJECT_ID/medisupply/edge-proxy:latest

    - name: Update Kubernetes manifests
      run: |
        # Replace PROJECT_ID and image tags in manifests
        find k8s -name "*-deployment.yaml" -exec sed -i "s/PROJECT_ID/$PROJECT_ID/g" {} \;
        find k8s -name "*-deployment.yaml" -exec sed -i "s/:latest/:$GITHUB_SHA/g" {} \;

    - name: Clean up before deploy
      env:
        USE_GKE_GCLOUD_AUTH_PLUGIN: True
      run: |
        echo "ğŸ§¹ Ejecutando limpieza pre-deploy..."
        ./scripts/cleanup-k8s.sh

    - name: Deploy to GKE
      env:
        USE_GKE_GCLOUD_AUTH_PLUGIN: True
      run: |
        # Aplicar namespace
        kubectl apply -f k8s/namespace.yaml
        
        # Desplegar recursos de base de datos (usando emptyDir, sin PVC)
        echo "ğŸ“¦ Desplegando recursos de base de datos..."
        echo "â„¹ï¸  PostgreSQL usa emptyDir (sin persistencia) para evitar problemas con PVC en GKE Autopilot"
        echo "âš ï¸  ADVERTENCIA: Los datos se perderÃ¡n al reiniciar el pod de PostgreSQL"
        kubectl apply -f k8s/database/postgres-secret.yaml
        kubectl apply -f k8s/database/postgres-init-configmap.yaml
        kubectl apply -f k8s/database/postgres-service.yaml
        
        # Desplegar deployment de PostgreSQL
        echo "ğŸ“¦ Desplegando PostgreSQL deployment..."
        kubectl apply -f k8s/database/postgres-deployment.yaml
        
        # Esperar a que PostgreSQL estÃ© listo antes de inicializar bases de datos
        echo "â³ Esperando a que PostgreSQL estÃ© listo..."
        PG_POD=$(kubectl get pod -n medisupply -l app=postgres -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
        if [ -z "$PG_POD" ]; then
          echo "â³ Esperando a que el pod de PostgreSQL aparezca..."
          for i in {1..30}; do
            PG_POD=$(kubectl get pod -n medisupply -l app=postgres -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
            if [ ! -z "$PG_POD" ]; then
              break
            fi
            sleep 2
          done
        fi
        
        if [ ! -z "$PG_POD" ]; then
          echo "â³ Esperando a que PostgreSQL responda..."
          for i in {1..30}; do
            if kubectl exec -n medisupply "$PG_POD" -- pg_isready -U mediadmin -d postgres 2>/dev/null; then
              echo "âœ… PostgreSQL estÃ¡ listo"
              break
            fi
            echo "Esperando PostgreSQL... (intento $i/30)"
            sleep 5
          done
        else
          echo "âš ï¸  No se encontrÃ³ pod de PostgreSQL, el Job de inicializaciÃ³n esperarÃ¡ internamente"
        fi
        
        # Ejecutar Job de inicializaciÃ³n de bases de datos (idempotente)
        echo "ğŸ“¦ Ejecutando inicializaciÃ³n de bases de datos..."
        kubectl delete job -n medisupply db-init-job --ignore-not-found=true
        kubectl apply -f k8s/database/db-init-job.yaml
        
        # Esperar a que el Job complete (mÃ¡ximo 2 minutos)
        echo "â³ Esperando inicializaciÃ³n de bases de datos..."
        kubectl wait --for=condition=complete --timeout=120s job/db-init-job -n medisupply || {
          echo "âš ï¸  Job de inicializaciÃ³n no completÃ³ en 2 minutos (puede estar ejecutÃ¡ndose todavÃ­a)"
          echo "ğŸ“‹ Estado del job:"
          kubectl get job -n medisupply db-init-job
          echo "â„¹ï¸  Continuando con el deploy, los servicios crearÃ¡n tablas automÃ¡ticamente si es necesario"
        }
        
        # Limpiar recursos de networking innecesarios (optimizaciÃ³n de costos)
        echo "ğŸ§¹ Limpiando recursos de networking innecesarios..."
        echo "â„¹ï¸  Eliminando LoadBalancer innecesario en user-service (se cambiarÃ¡ a ClusterIP)"
        # Si el servicio existe como LoadBalancer, lo eliminamos para que se recree como ClusterIP
        if kubectl get service user-service -n medisupply -o jsonpath='{.spec.type}' 2>/dev/null | grep -q "LoadBalancer"; then
          echo "âš ï¸  user-service tiene type: LoadBalancer, eliminando para cambiar a ClusterIP..."
          kubectl delete service user-service -n medisupply --ignore-not-found=true
          echo "âœ… LoadBalancer innecesario eliminado"
        else
          echo "âœ… user-service ya estÃ¡ configurado correctamente (ClusterIP o no existe)"
        fi
        
        echo "â„¹ï¸  Eliminando Ingress antiguo si existe (ya no se usa, Gateway API es el mÃ©todo actual)"
        kubectl delete ingress medisupply-ingress -n medisupply --ignore-not-found=true || true
        echo "âœ… Limpieza de networking completada"
        
        # Desplegar servicios
        echo "ğŸ“¦ Desplegando servicios..."
        kubectl apply -f k8s/services/user-service/
        kubectl apply -f k8s/services/supplier-service/
        kubectl apply -f k8s/services/client-service/
        kubectl apply -f k8s/gateway/
        
        # Aplicar HPA para optimizaciÃ³n de costos
        echo "ğŸš€ Aplicando Horizontal Pod Autoscalers..."
        kubectl apply -f k8s/services/user-service/hpa-user-service.yaml || echo "HPA no encontrado, omitiendo..."
        kubectl apply -f k8s/services/supplier-service/hpa-supplier-service.yaml || echo "HPA no encontrado, omitiendo..."
        kubectl apply -f k8s/services/client-service/hpa-client-service.yaml || echo "HPA no encontrado, omitiendo..."
        
        # Esperar a que los deployments estÃ©n listos (sin bloqueos largos)
        echo "â³ Esperando deployments..."
        
        # User Service (timeout generoso con startupProbe)
        echo "â³ Esperando user-service (puede tardar hasta 5 minutos con startupProbe)..."
        kubectl rollout status deployment/user-service-deployment -n medisupply --timeout=600s || {
          echo "âš ï¸  User-service rollout timeout (continuando de todas formas)"
          echo "ğŸ“‹ DiagnÃ³stico:"
          kubectl get pods -l app=user-service -n medisupply -o wide
          kubectl get events -n medisupply --field-selector involvedObject.kind=Pod --sort-by='.lastTimestamp' | grep user-service | tail -5
          echo "â„¹ï¸  Kubernetes continuarÃ¡ intentando hasta que el servicio estÃ© listo"
        }
        
        # Supplier Service
        kubectl rollout status deployment/supplier-service-deployment -n medisupply --timeout=300s || {
          echo "âš ï¸  Supplier-service rollout timeout"
          echo "ğŸ“‹ Estado del deployment:"
          kubectl describe deployment supplier-service-deployment -n medisupply | head -50
          echo "ğŸ“‹ Pods:"
          kubectl get pods -l app=supplier-service -n medisupply
          echo "ğŸ“‹ Logs (Ãºltimas 20 lÃ­neas):"
          kubectl logs -l app=supplier-service -n medisupply --tail=20 2>/dev/null || echo "No logs disponibles"
        }
        
        # Client Service
        kubectl rollout status deployment/client-service-deployment -n medisupply --timeout=300s || {
          echo "âš ï¸  Client-service rollout timeout"
          echo "ğŸ“‹ Estado del deployment:"
          kubectl describe deployment client-service-deployment -n medisupply | head -50
          echo "ğŸ“‹ Pods:"
          kubectl get pods -l app=client-service -n medisupply
          echo "ğŸ“‹ Logs (Ãºltimas 20 lÃ­neas):"
          kubectl logs -l app=client-service -n medisupply --tail=20 2>/dev/null || echo "No logs disponibles"
        }
        
        # PostgreSQL (opcional, no bloquea - servicios son resilientes con pool_pre_ping)
        echo "â³ Verificando PostgreSQL (no bloquea el workflow)..."
        kubectl rollout status deployment/postgres-deployment -n medisupply --timeout=180s || {
          echo "âš ï¸  PostgreSQL rollout timeout (continuando de todas formas)"
          echo "ğŸ“‹ DiagnÃ³stico:"
          kubectl get pods -l app=postgres -n medisupply -o wide
          echo "â„¹ï¸  Los servicios son resilientes y continuarÃ¡n funcionando cuando PostgreSQL estÃ© listo"
        }

    - name: Verify deployment
      env:
        USE_GKE_GCLOUD_AUTH_PLUGIN: True
      run: |
        echo "ğŸ“Š Estado de pods:"
        kubectl get pods -n medisupply
        echo ""
        echo "ğŸ“Š Servicios:"
        kubectl get services -n medisupply
        echo ""
        echo "ğŸ“Š Gateway:"
        kubectl get gateway -n medisupply || echo "Gateway no disponible aÃºn"
        echo ""
        echo "ğŸ“Š HPA Status:"
        kubectl get hpa -n medisupply || echo "HPA no configurado"

    - name: Get Gateway IP
      id: get-ip
      env:
        USE_GKE_GCLOUD_AUTH_PLUGIN: True
      run: |
        echo "ğŸ” Esperando IP externa del Gateway..."
        for i in {1..30}; do
          IP=$(kubectl get gateway medisupply-gateway -n medisupply -o jsonpath='{.status.addresses[0].value}' 2>/dev/null || echo "")
          if [ ! -z "$IP" ]; then
            echo "ip=$IP" >> $GITHUB_OUTPUT
            echo "ğŸ‰ Â¡IP externa obtenida: $IP!"
            break
          fi
          echo "Esperando IP externa... (intento $i/30)"
          sleep 10
        done

    - name: Deploy HTTPS Edge (Cloud Run)
      id: deploy-edge
      if: steps.get-ip.outputs.ip != ''
      env:
        USE_GKE_GCLOUD_AUTH_PLUGIN: True
      run: |
        EDGE_IMAGE="$REGISTRY/$PROJECT_ID/medisupply/edge-proxy:$GITHUB_SHA"
        EDGE_SVC="medisupply-edge-proxy"
        REGION="$GKE_REGION"
        UPSTREAM="http://${{ steps.get-ip.outputs.ip }}"

        echo "Deploying $EDGE_SVC to $UPSTREAM ..."
        gcloud run deploy "$EDGE_SVC" \
          --image "$EDGE_IMAGE" \
          --region "$REGION" \
          --allow-unauthenticated \
          --max-instances 3 \
          --set-env-vars UPSTREAM="$UPSTREAM",ALLOWED_ORIGINS="*"

        EDGE_URL=$(gcloud run services describe "$EDGE_SVC" --region "$REGION" --format='value(status.url)')
        echo "edge_url=$EDGE_URL" >> $GITHUB_OUTPUT
        echo "HTTPS EDGE URL: $EDGE_URL"

    - name: Update deployment status
      if: steps.get-ip.outputs.ip != ''
      run: |
        echo "ğŸš€ Deploy completed"
        echo "ğŸŒ App (HTTP via GKE Gateway): http://${{ steps.get-ip.outputs.ip }}"
        echo "ğŸ”’ HTTPS Edge (Cloud Run): ${{ steps.deploy-edge.outputs.edge_url }}"
        echo ""
        echo "â¤ï¸ HEALTH CHECKS (via HTTPS edge):"
        echo "   User Service: ${{ steps.deploy-edge.outputs.edge_url }}/health"
        echo "   Supplier Service: ${{ steps.deploy-edge.outputs.edge_url }}/healthz"
        echo "   Client Service: ${{ steps.deploy-edge.outputs.edge_url }}/client-health"
        echo ""
        echo "ğŸ”Œ APIs (USE the HTTPS Edge from the web client):"
        echo "   ğŸ‘¥ Users: ${{ steps.deploy-edge.outputs.edge_url }}/api/v1/users"
        echo "   ğŸ‘¥ Providers: ${{ steps.deploy-edge.outputs.edge_url }}/api/v1/providers"
        echo "   ğŸ¥ Suppliers (ES): ${{ steps.deploy-edge.outputs.edge_url }}/api/v1/proveedores"
        echo "   ğŸ¥ Products: ${{ steps.deploy-edge.outputs.edge_url }}/api/v1/productos"
        echo "   ğŸ¥ Sales Plans: ${{ steps.deploy-edge.outputs.edge_url }}/api/v1/planes-venta"
        echo "   ğŸ¥ Sellers: ${{ steps.deploy-edge.outputs.edge_url }}/api/v1/vendedores"
        echo "   ğŸ¥ Countries: ${{ steps.deploy-edge.outputs.edge_url }}/api/v1/paises"
        echo "   ğŸ¥ Certifications: ${{ steps.deploy-edge.outputs.edge_url }}/api/v1/certificaciones"
        echo "   ğŸ¥ Categories: ${{ steps.deploy-edge.outputs.edge_url }}/api/v1/categorias-suministros"
        echo "   ğŸ¢ Clients: ${{ steps.deploy-edge.outputs.edge_url }}/api/v1/clientes"
