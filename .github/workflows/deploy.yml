name: Deploy to GKE

on:
  push:
    branches: [main]

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GKE_CLUSTER: medisupply-cluster
  GKE_REGION: us-central1
  REGISTRY: us-central1-docker.pkg.dev

jobs:
  deploy:
    name: Deploy to GKE
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
        project_id: ${{ secrets.GCP_PROJECT_ID }}

    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2

    - name: Install GKE Auth Plugin
      run: |
        gcloud components install gke-gcloud-auth-plugin
        echo "USE_GKE_GCLOUD_AUTH_PLUGIN=True" >> $GITHUB_ENV

    - name: Configure Docker for Artifact Registry
      run: gcloud --quiet auth configure-docker us-central1-docker.pkg.dev

    - name: Get GKE credentials
      run: |
        export USE_GKE_GCLOUD_AUTH_PLUGIN=True
        gcloud container clusters get-credentials $GKE_CLUSTER --region $GKE_REGION

    - name: Build and push user-service image
      run: |
        # Build image
        docker build -t $REGISTRY/$PROJECT_ID/medisupply/user-service:$GITHUB_SHA ./user-service
        docker tag $REGISTRY/$PROJECT_ID/medisupply/user-service:$GITHUB_SHA $REGISTRY/$PROJECT_ID/medisupply/user-service:latest
        
        # Push image
        docker push $REGISTRY/$PROJECT_ID/medisupply/user-service:$GITHUB_SHA
        docker push $REGISTRY/$PROJECT_ID/medisupply/user-service:latest

    - name: Build and push supplier-service image
      run: |
        # Build supplier-service image
        docker build -t $REGISTRY/$PROJECT_ID/medisupply/supplier-service:$GITHUB_SHA ./medisupply-supplier-service
        docker tag $REGISTRY/$PROJECT_ID/medisupply/supplier-service:$GITHUB_SHA $REGISTRY/$PROJECT_ID/medisupply/supplier-service:latest
        
        # Push image
        docker push $REGISTRY/$PROJECT_ID/medisupply/supplier-service:$GITHUB_SHA
        docker push $REGISTRY/$PROJECT_ID/medisupply/supplier-service:latest

    - name: Build and push client-service image
      run: |
        # Build client-service image
        docker build -t $REGISTRY/$PROJECT_ID/medisupply/client-service:$GITHUB_SHA ./medisupply-client-service
        docker tag $REGISTRY/$PROJECT_ID/medisupply/client-service:$GITHUB_SHA $REGISTRY/$PROJECT_ID/medisupply/client-service:latest
        
        # Push image
        docker push $REGISTRY/$PROJECT_ID/medisupply/client-service:$GITHUB_SHA
        docker push $REGISTRY/$PROJECT_ID/medisupply/client-service:latest

    - name: Update Kubernetes manifests
      run: |
        # Replace PROJECT_ID and image tag in manifests
        sed -i "s/PROJECT_ID/$PROJECT_ID/g" k8s/services/user-service/user-service-deployment.yaml
        sed -i "s/:latest/:$GITHUB_SHA/g" k8s/services/user-service/user-service-deployment.yaml
        
        # Update supplier-service manifests
        sed -i "s/PROJECT_ID/$PROJECT_ID/g" k8s/services/supplier-service/supplier-service-deployment.yaml
        
        # Update image tags for both main and init containers
        sed -i "s|supplier-service:latest|supplier-service:$GITHUB_SHA|g" k8s/services/supplier-service/supplier-service-deployment.yaml
        sed -i "s|supplier-service-init:latest|supplier-service-init:$GITHUB_SHA|g" k8s/services/supplier-service/supplier-service-deployment.yaml
        
        # Update client-service manifests
        if [ -f "k8s/services/client-service/client-service-deployment.yaml" ]; then
          sed -i "s/PROJECT_ID/$PROJECT_ID/g" k8s/services/client-service/client-service-deployment.yaml
          sed -i "s|client-service:latest|client-service:$GITHUB_SHA|g" k8s/services/client-service/client-service-deployment.yaml
        fi

    - name: Clean up before deploy
      env:
        USE_GKE_GCLOUD_AUTH_PLUGIN: True
      run: |
        echo "ğŸ§¹ Ejecutando limpieza pre-deploy..."
        ./scripts/cleanup-k8s.sh

    - name: Deploy to GKE
      env:
        USE_GKE_GCLOUD_AUTH_PLUGIN: True
      run: |
        # Apply namespace
        kubectl apply -f k8s/namespace.yaml
        
        # Deploy database resources (PVC first, then wait for it to be Bound)
        echo "ğŸ“¦ Desplegando recursos de base de datos..."
        kubectl apply -f k8s/database/postgres-pvc.yaml
        kubectl apply -f k8s/database/postgres-service.yaml
        kubectl apply -f k8s/database/postgres-secret.yaml
        kubectl apply -f k8s/database/postgres-init-configmap.yaml
        
        # Wait for PVC to be Bound (critical: deployment can't schedule without Bound PVC)
        echo "â³ Esperando que el PVC estÃ© Bound..."
        PVC_READY=false
        for i in {1..60}; do
          PVC_STATUS=$(kubectl get pvc postgres-pvc -n medisupply -o jsonpath='{.status.phase}' 2>/dev/null || echo "")
          if [ "$PVC_STATUS" = "Bound" ]; then
            echo "âœ… PVC estÃ¡ Bound y listo (check $i/60, ~$((i*5))s)"
            PVC_READY=true
            break
          fi
          if [ $((i % 6)) -eq 0 ]; then
            echo "â³ Esperando PVC... (check $i/60, ~$((i*5))s) - Estado: ${PVC_STATUS:-Creating}"
          fi
          sleep 5
        done
        
        if [ "$PVC_READY" = "false" ]; then
          echo "âŒ PVC no estÃ¡ Bound despuÃ©s de 5 minutos"
          echo "ğŸ“‹ Estado del PVC:"
          kubectl describe pvc postgres-pvc -n medisupply || true
          echo "âš ï¸  Continuando de todas formas..."
        fi
        
        # Eliminar deployment antiguo si existe (para evitar pods en Pending)
        echo "ğŸ§¹ Limpiando deployment antiguo de PostgreSQL si existe..."
        kubectl delete deployment postgres-deployment -n medisupply --ignore-not-found=true --timeout=10s || true
        sleep 3
        
        # Now deploy database deployment (after PVC is ready)
        echo "ğŸ“¦ Desplegando deployment de PostgreSQL..."
        kubectl apply -f k8s/database/postgres-deployment.yaml
        
        # Wait for database deployment to be created
        echo "â³ Esperando que el deployment de PostgreSQL estÃ© disponible..."
        for i in {1..10}; do
          if kubectl get deployment postgres-deployment -n medisupply 2>/dev/null; then
            echo "âœ… Deployment de PostgreSQL encontrado"
            break
          fi
          echo "Intento $i/10..."
          sleep 2
        done
        
        # Wait for PostgreSQL pod to be Running and ready
        echo "â³ Esperando que el pod de PostgreSQL estÃ© Running y listo..."
        POSTGRES_READY=false
        PENDING_COUNT=0
        for i in {1..72}; do  # 6 minutos mÃ¡ximo
          POD_NAME=$(kubectl get pod -l app=postgres -n medisupply -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          if [ ! -z "$POD_NAME" ]; then
            POD_PHASE=$(kubectl get pod $POD_NAME -n medisupply -o jsonpath='{.status.phase}' 2>/dev/null || echo "")
            
            # Si el pod estÃ¡ en Pending, verificar por quÃ©
            if [ "$POD_PHASE" = "Pending" ]; then
              PENDING_COUNT=$((PENDING_COUNT + 1))
              POD_CONDITION=$(kubectl get pod $POD_NAME -n medisupply -o jsonpath='{.status.conditions[?(@.type=="PodScheduled")].message}' 2>/dev/null || echo "")
              
              # Si lleva mÃ¡s de 60 segundos en Pending y el PVC estÃ¡ Bound, recrear el deployment
              if [ $PENDING_COUNT -ge 12 ] && [ "$PVC_READY" = "true" ]; then
                echo "âš ï¸  Pod lleva mÃ¡s de 1 minuto en Pending con PVC Bound, recreando deployment..."
                kubectl delete deployment postgres-deployment -n medisupply --timeout=10s || true
                sleep 5
                kubectl apply -f k8s/database/postgres-deployment.yaml
                PENDING_COUNT=0
                sleep 10
                continue
              fi
              
              if echo "$POD_CONDITION" | grep -q "unbound PersistentVolumeClaims"; then
                echo "â³ Pod esperando PVC (esto no deberÃ­a pasar ya que PVC estÃ¡ Bound)..."
                sleep 5
                continue
              fi
            fi
            
            if [ "$POD_PHASE" = "Running" ]; then
              # Verificar que realmente estÃ© listo y aceptando conexiones
              if kubectl exec -n medisupply $POD_NAME -- pg_isready -U mediadmin -d users_db 2>/dev/null; then
                echo "âœ… PostgreSQL estÃ¡ Running y aceptando conexiones (check $i/72, ~$((i*5))s)"
                POSTGRES_READY=true
                break
              fi
            fi
          fi
          if [ $((i % 12)) -eq 0 ]; then
            echo "â³ Esperando PostgreSQL... (check $i/72, ~$((i*5))s) - Fase: ${POD_PHASE:-unknown}"
          fi
          sleep 5
        done
        
        if [ "$POSTGRES_READY" = "false" ]; then
          echo "âŒ PostgreSQL no estÃ¡ listo despuÃ©s de 6 minutos"
          echo "ğŸ“Š Estado del pod:"
          kubectl get pods -l app=postgres -n medisupply || echo "No pods found"
          echo "ğŸ“‹ Estado del PVC:"
          kubectl get pvc postgres-pvc -n medisupply || echo "PVC not found"
          POD_NAME=$(kubectl get pod -l app=postgres -n medisupply -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          if [ ! -z "$POD_NAME" ]; then
            echo "=== Describe Pod ==="
            kubectl describe pod $POD_NAME -n medisupply || true
            echo "=== Pod Logs (last 30 lines) ==="
            kubectl logs $POD_NAME -n medisupply --tail=30 2>/dev/null || echo "No logs available"
          fi
          exit 1
        fi
        
        # Show postgres pod status and logs for debugging
        echo "=== PostgreSQL Pod Status ==="
        kubectl get pods -l app=postgres -n medisupply || echo "No pods found"
        echo "=== PostgreSQL Logs (last 20 lines) ==="
        kubectl logs -l app=postgres -n medisupply --tail=20 2>/dev/null || echo "No logs available yet"
        
        # Deploy user-service
        kubectl apply -f k8s/services/user-service/
        
        # Deploy supplier-service
        kubectl apply -f k8s/services/supplier-service/
        
        # Deploy client-service
        if [ -d "k8s/services/client-service" ]; then
          kubectl apply -f k8s/services/client-service/
        else
          echo "âš ï¸  Client service manifests not found, skipping..."
        fi
        
        # Wait for deployments to complete
        kubectl rollout status deployment/user-service-deployment -n medisupply --timeout=600s
        kubectl rollout status deployment/supplier-service-deployment -n medisupply --timeout=600s
        
        # Wait for client-service deployment if it exists
        if kubectl get deployment client-service-deployment -n medisupply 2>/dev/null; then
          echo "â³ Esperando client-service..."
          # Mostrar logs si el rollout falla
          kubectl rollout status deployment/client-service-deployment -n medisupply --timeout=600s || {
            echo "âš ï¸  Client-service rollout fallÃ³ o excediÃ³ timeout"
            echo "ğŸ“‹ Estado del deployment:"
            kubectl describe deployment client-service-deployment -n medisupply
            echo "ğŸ“‹ Pods del client-service:"
            kubectl get pods -l app=client-service -n medisupply
            echo "ğŸ“‹ Logs del pod (Ãºltimas 50 lÃ­neas):"
            kubectl logs -l app=client-service -n medisupply --tail=50 || echo "No hay logs disponibles aÃºn"
            exit 1
          }
        fi
        
        # Deploy HPA for auto-scaling (cost optimization)
        echo "ğŸš€ Applying Horizontal Pod Autoscalers for cost optimization..."
        kubectl apply -f k8s/services/user-service/hpa-user-service.yaml || echo "HPA not found, skipping..."
        kubectl apply -f k8s/services/supplier-service/hpa-supplier-service.yaml || echo "HPA not found, skipping..."
        kubectl apply -f k8s/services/client-service/hpa-client-service.yaml || echo "HPA not found, skipping..."
        
        # Deploy gateway (GKE Autopilot uses Gateway API instead of Ingress)
        kubectl apply -f k8s/gateway/

    - name: Verify deployment
      env:
        USE_GKE_GCLOUD_AUTH_PLUGIN: True
      run: |
        kubectl get pods -n medisupply
        kubectl get services -n medisupply
        kubectl get gateway -n medisupply
        echo ""
        echo "ğŸ“Š HPA Status (Cost Optimization):"
        kubectl get hpa -n medisupply || echo "HPA not configured"

    - name: Get Gateway IP
      id: get-ip
      env:
        USE_GKE_GCLOUD_AUTH_PLUGIN: True
      run: |
        # Esperar hasta 8 minutos por la IP externa del Gateway
        echo "ğŸ” Esperando IP externa del Gateway..."
        for i in {1..48}; do
          IP=$(kubectl get gateway medisupply-gateway -n medisupply -o jsonpath='{.status.addresses[0].value}' 2>/dev/null || echo "")
          if [ ! -z "$IP" ]; then
            echo "ip=$IP" >> $GITHUB_OUTPUT
            echo "ğŸ‰ Â¡IP externa obtenida: $IP!"
            echo "ğŸŒ API disponible en: http://$IP"
            break
          fi
          echo "Esperando IP externa... (intento $i/48)"
          sleep 10
        done
        
        # Si no se obtuvo IP, mostrar mensaje informativo
        if [ -z "$IP" ]; then
          echo ""
          echo "â³ NORMAL: Los Load Balancers de GCP pueden tardar 5-10 minutos en asignar IP externa."
          echo "ğŸ¯ El deploy SÃ funcionÃ³ correctamente. Solo falta la IP externa."
          echo ""
          echo "ğŸ“‹ Para obtener la IP cuando estÃ© lista, ejecuta en Cloud Shell:"
          echo "   kubectl get gateway medisupply-gateway -n medisupply"
          echo ""
          echo "ğŸ”„ Para monitorear en tiempo real:"
          echo "   kubectl get gateway medisupply-gateway -n medisupply -w"
          echo ""
          echo "âœ… La aplicaciÃ³n ya estÃ¡ funcionando internamente en el cluster."
        fi

    - name: Update deployment status
      if: steps.get-ip.outputs.ip != ''
      run: |
        echo "ğŸš€ Â¡Deploy exitoso!"
        echo "ğŸŒ URL de la aplicaciÃ³n: http://${{ steps.get-ip.outputs.ip }}"
        echo ""
        echo "â¤ï¸ HEALTH CHECKS:"
        echo "   User Service: http://${{ steps.get-ip.outputs.ip }}/health"
        echo "   Supplier Service: http://${{ steps.get-ip.outputs.ip }}/healthz"
        echo "   Client Service: http://${{ steps.get-ip.outputs.ip }}/client-health"
        echo ""
        echo "ğŸ”Œ APIS DISPONIBLES:"
        echo "   ğŸ‘¥ Usuarios: http://${{ steps.get-ip.outputs.ip }}/api/v1/users"
        echo "   ğŸ‘¥ Providers: http://${{ steps.get-ip.outputs.ip }}/api/v1/providers"
        echo "   ğŸ¥ Proveedores: http://${{ steps.get-ip.outputs.ip }}/api/v1/proveedores"
        echo "   ğŸ¥ Productos: http://${{ steps.get-ip.outputs.ip }}/api/v1/productos"
        echo "   ğŸ¥ Planes de venta: http://${{ steps.get-ip.outputs.ip }}/api/v1/planes-venta"
        echo "   ğŸ¥ Vendedores: http://${{ steps.get-ip.outputs.ip }}/api/v1/vendedores"
        echo "   ğŸ¥ PaÃ­ses: http://${{ steps.get-ip.outputs.ip }}/api/v1/paises"
        echo "   ğŸ¥ Certificaciones: http://${{ steps.get-ip.outputs.ip }}/api/v1/certificaciones"
        echo "   ğŸ¥ CategorÃ­as: http://${{ steps.get-ip.outputs.ip }}/api/v1/categorias-suministros"
        echo "   ğŸ¢ Clientes: http://${{ steps.get-ip.outputs.ip }}/api/v1/clientes"
        echo ""
        echo "ğŸ“š NOTA: DocumentaciÃ³n disponible internamente en los servicios:"
        echo "   User Service: /docs, /openapi.json (usar port-forward para acceder)"
        echo "   Supplier Service: /supplier-docs, /supplier-openapi.json (usar port-forward)"
        echo "   Client Service: /client-docs, /client-openapi.json (usar port-forward)"
